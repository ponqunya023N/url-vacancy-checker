#!/usr/bin/env python3
# -- coding: utf-8 --  # [002]
  # [003]
import os  # [004]
import json  # [005]
import urllib.request  # [006]
import urllib.parse  # [007]
import hashlib  # [008]
import re  # [009]
from datetime import datetime, timedelta, timezone  # [010]
from playwright.sync_api import sync_playwright, TimeoutError  # [011]
  # [012]
# ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ï¼çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«  # [013]
JST = timezone(timedelta(hours=9))  # [014]
STATUS_FILE = "status.json"  # [015]
  # [016]
def timestamp() -> str:  # [017]
    return datetime.now(JST).strftime("%Y-%m-%d %H:%M:%S JST")  # [018]
  # [019]
# æš—å·åŒ–ï¼ˆãƒãƒƒã‚·ãƒ¥åŒ–ï¼‰ç”¨ã®é–¢æ•°  # [020]
def make_hash(text: str) -> str:  # [021]
    # å‰å¾Œã®ç©ºç™½ã«ã‚ˆã‚‹æºã‚‰ãã‚’é˜²ããŸã‚strip()ã‚’é©ç”¨  # [022]
    clean_text = text.strip()  # [023]
    return hashlib.sha256(clean_text.encode('utf-8')).hexdigest()[:12]  # [024]
  # [025]
# Secretsã‹ã‚‰èª­ã¿è¾¼ã‚“ã æ–‡å­—åˆ—ã‚’ãƒªã‚¹ãƒˆã«å¤‰æ›  # [026]
def parse_targets(raw_str: str) -> list:  # [027]
    targets = []  # [028]
    if not raw_str: return targets  # [029]
    parts = raw_str.split(',')  # [030]
    for part in parts:  # [031]
        if '|' in part:  # [032]
            name, url = part.strip().split('|', 1)  # [033]
            targets.append((name.strip(), url.strip()))  # [034]
    return targets  # [035]
  # [036]
def judge_vacancy(browser, name: str, url: str) -> dict:  # [037]
    page = browser.new_page()  # [038]
    result = {"status": "unknown", "details": []}  # [039]
    try:  # [040]
        # å¼·åˆ¶çµ‚äº†ã‚’é¿ã‘ã‚‹ãŸã‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šã‚’é©åˆ‡ã«  # [041]
        page.goto(url, timeout=40000, wait_until="load")  # [042]
          # [043]
        try:  # [044]
            page.wait_for_selector("tbody.rep_room tr", timeout=15000)  # [045]
        except TimeoutError:  # [046]
            pass  # [047]
  # [048]
        rows = page.query_selector_all("tbody.rep_room tr")  # [049]
          # [050]
        # ãƒ­ã‚°ã«ã¯åå‰ã‚’å‡ºã•ãšã€ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã®ã¿å‡ºåŠ›ã™ã‚‹  # [051]
        match = re.match(r'(ã€.*?ã€‘)', name)  # [052]
        prefix = match.group(1) if match else "ã€ä¸æ˜ã€‘"  # [053]
        # æ¤œå‡ºä»¶æ•°ã®ã¿ã¾ãšå‡ºåŠ›ï¼ˆãƒãƒƒã‚·ãƒ¥è©³ç´°ã¯mainå´ã§åˆ¤å®šå¾Œã«ãƒ­ã‚°å‡ºåŠ›ï¼‰  # [054]
        print(f"[{timestamp()}] [DEBUG] {prefix}***: {len(rows)}ä»¶æ¤œå‡º")  # [055]
  # [056]
        if rows:  # [057]
            found_valid_room = False  # [058]
            for i, row in enumerate(rows, 1):  # [059]
                try:  # [060]
                    rent_elem = row.query_selector("span.rep_room-price")  # [061]
                    if not rent_elem: continue  # [062]
                    rent = rent_elem.inner_text().strip()  # [063]
                    if not rent or rent == "ä¸æ˜": continue  # [064]
  # [065]
                    found_valid_room = True  # [066]
                    common_elem = row.query_selector("span.rep_room-commonfee")  # [067]
                    room_name_elem = row.query_selector("td.rep_room-name")  # [068]
                      # [069]
                    common = common_elem.inner_text().strip() if common_elem else ""  # [070]
                    room_name = room_name_elem.inner_text().strip() if room_name_elem else f"éƒ¨å±‹{i}"  # [071]
  # [072]
                    # ç”»åƒå–å¾—  # [073]
                    img_url = ""  # [074]
                    img_elem = row.query_selector("img.rep_room-madori-src")  # [075]
                    if not img_elem:  # [076]
                        img_elem = row.query_selector("div.item_image img")  # [077]
  # [078]
                    if img_elem:  # [079]
                        src = img_elem.get_attribute("src")  # [080]
                        if src and "icn_" not in src and "button" not in src:  # [081]
                            img_url = urllib.parse.urljoin("https://www.ur-net.go.jp", src)  # [082]
  # [083]
                    # éƒ¨å±‹åï¼ˆå»ºç‰©åå«ã‚€ï¼‰ã®è©³ç´°ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã—ã€jsonä¿å­˜ç”¨ã®æš—å·åŒ–IDã‚‚æŒãŸã›ã‚‹  # [084]
                    result["details"].append({  # [085]
                        "room_hash": make_hash(room_name),   # [086]
                        "text": f"ğŸ¢ <b>{room_name}</b>\nå®¶è³ƒ: {rent} (å…±ç›Šè²»: {common})",  # [087]
                        "img_url": img_url  # [088]
                    })  # [089]
                except Exception:  # [090]
                    # ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã®éš è”½  # [091]
                    print(f"  [DEBUG] éƒ¨å±‹ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼ï¼ˆè©³ç´°ã¯ç§˜åŒ¿ã•ã‚Œã¦ã„ã¾ã™ï¼‰")  # [092]
                    continue  # [093]
              # [094]
            if found_valid_room:  # [095]
                result["status"] = "available"  # [096]
                return result  # [097]
  # [098]
        if "ã”ã–ã„ã¾ã›ã‚“" in page.content() or page.query_selector(".err-box"):  # [099]
            result["status"] = "not_available"  # [100]
          # [101]
        return result  # [102]
    except Exception:  # [103]
        # ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã®å¾¹åº•çš„ãªéš è”½  # [104]
        print(f"[{timestamp()}] é€šä¿¡ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿï¼ˆå¯¾è±¡URLç­‰ã®è©³ç´°ã¯ç§˜åŒ¿ã•ã‚Œã¦ã„ã¾ã™ï¼‰")  # [105]
        result["status"] = "error"  # [106]
        return result  # [107]
    finally:  # [108]
        page.close()  # [109]
  # [110]
def send_telegram(name: str, url: str, new_rooms_details: list) -> None:  # [111]
    token = os.getenv("TELEGRAM_BOT_TOKEN")  # [112]
    chat_id = os.getenv("TELEGRAM_CHAT_ID")  # [113]
    if not token or not chat_id: return  # [114]
  # [115]
    def call_api(method, payload):  # [116]
        api_url = f"https://api.telegram.org/bot{token}/{method}"  # [117]
        req = urllib.request.Request(api_url, data=json.dumps(payload).encode("utf-8"), headers={"Content-Type": "application/json"})  # [118]
        with urllib.request.urlopen(req) as response:  # [119]
            return response.read()  # [120]
  # [121]
    try:  # [122]
        call_api("sendMessage", {  # [123]
            "chat_id": chat_id,  # [124]
            "text": f"ğŸŒŸ <b>URç©ºå®¤ç™ºè¦‹ï¼ˆæ–°ç€ï¼‰ï¼</b>\n\nç‰©ä»¶: <b>{name}</b>\nğŸ”— <a href='{url}'>ç‰©ä»¶è©³ç´°ãƒšãƒ¼ã‚¸</a>\nâ° {timestamp()}",  # [125]
            "parse_mode": "HTML",  # [126]
            "disable_web_page_preview": True  # [127]
        })  # [128]
        for detail in new_rooms_details:  # [129]
            if detail["img_url"]:  # [130]
                try:  # [131]
                    call_api("sendPhoto", {"chat_id": chat_id, "photo": detail["img_url"], "caption": detail["text"], "parse_mode": "HTML"})  # [132]
                except:  # [133]
                    call_api("sendMessage", {"chat_id": chat_id, "text": detail["text"], "parse_mode": "HTML"})  # [134]
            else:  # [135]
                call_api("sendMessage", {"chat_id": chat_id, "text": detail["text"], "parse_mode": "HTML"})  # [136]
    except Exception:  # [137]
        print("Telegramé€ä¿¡ã‚¨ãƒ©ãƒ¼ï¼ˆè©³ç´°ã¯ç§˜åŒ¿ã•ã‚Œã¦ã„ã¾ã™ï¼‰")  # [138]
  # [139]
def main() -> None:  # [140]
    if os.path.exists(STATUS_FILE):  # [141]
        try:  # [142]
            with open(STATUS_FILE, "r", encoding="utf-8") as f:  # [143]
                prev = json.load(f)  # [144]
        except:  # [145]
            prev = {}  # [146]
    else:  # [147]
        prev = {}  # [148]
  # [149]
    next_status_data = {}  # [150]
      # [151]
    raw_targets = os.getenv("TARGET_URLS", "")  # [152]
    targets_list = parse_targets(raw_targets)  # [153]
  # [154]
    with sync_playwright() as p:  # [155]
        browser = p.chromium.launch(headless=True)  # [156]
        for name, url in targets_list:  # [157]
            match = re.match(r'(ã€.*?ã€‘)', name)  # [158]
            prefix = match.group(1) if match else "ã€ä¸æ˜ã€‘"  # [159]
            safe_key = f"{prefix}{make_hash(name)}"  # [160]
  # [161]
            res = judge_vacancy(browser, name, url)  # [162]
            s = res["status"]  # [163]
              # [164]
            # éå»ã«é€šçŸ¥æ¸ˆã¿ã®éƒ¨å±‹ãƒãƒƒã‚·ãƒ¥ãƒªã‚¹ãƒˆã‚’å–å¾—  # [165]
            prev_notified_hashes = prev.get(safe_key, [])  # [166]
            if not isinstance(prev_notified_hashes, list):  # [167]
                prev_notified_hashes = []  # [168]
  # [169]
            # ç¾åœ¨è¦‹ã¤ã‹ã£ãŸéƒ¨å±‹ã®ãƒãƒƒã‚·ãƒ¥ãƒªã‚¹ãƒˆ  # [170]
            current_rooms_hashes = [d["room_hash"] for d in res["details"]]  # [171]
              # [172]
            # ãƒ­ã‚°ã«ãƒãƒƒã‚·ãƒ¥å€¤ã‚’è¡¨ç¤ºã™ã‚‹ã‚ˆã†ã«è¿½åŠ ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰  # [173]
            hash_log = ", ".join(current_rooms_hashes) if current_rooms_hashes else "ãªã—"  # [174]
            print(f"[{timestamp()}] {safe_key}: {s} (ç¾åœ¨ãƒãƒƒã‚·ãƒ¥: {hash_log} / ä¿å­˜æ¸ˆã¿æ•°: {len(prev_notified_hashes)}ä»¶)")  # [175]
  # [176]
            if s in ["error", "unknown"]:  # [177]
                # ã‚¨ãƒ©ãƒ¼æ™‚ã¯ã“ã‚Œã¾ã§ã®å±¥æ­´ã‚’ãã®ã¾ã¾ç¶­æŒ  # [178]
                next_status_data[safe_key] = prev_notified_hashes  # [179]
            elif s == "not_available":  # [180]
                # ç©ºå®¤ãªã—ã§ã‚‚ã€éå»ã«é€šçŸ¥ã—ãŸå±¥æ­´ã¯æ¶ˆã•ãšã«ä¿æŒã—ç¶šã‘ã‚‹  # [181]
                next_status_data[safe_key] = prev_notified_hashes  # [182]
            else:  # [183]
                # ç¾åœ¨ã‚ã‚‹éƒ¨å±‹ã®ä¸­ã§ã€ã¾ã éå»ã®å±¥æ­´ã«å«ã¾ã‚Œã¦ã„ãªã„ã‚‚ã®ã ã‘ã‚’æŠ½å‡º  # [184]
                new_rooms_details = [d for d in res["details"] if d["room_hash"] not in prev_notified_hashes]  # [185]
  # [186]
                if new_rooms_details:  # [187]
                    send_telegram(name, url, new_rooms_details)  # [188]
                  # [189]
                # ä»Šå›è¦‹ã¤ã‹ã£ãŸãƒãƒƒã‚·ãƒ¥ã‚’æ—¢å­˜ã®å±¥æ­´ã«çµ±åˆï¼ˆé‡è¤‡æ’é™¤ï¼‰ã—ã¦ä¿å­˜  # [190]
                # ã“ã‚Œã«ã‚ˆã‚Šã€Œä¸€åº¦ã§ã‚‚è¦‹ã¤ã‘ãŸéƒ¨å±‹ã€ã¯æ°¸ç¶šçš„ã«è¨˜æ†¶ã•ã‚Œã‚‹  # [191]
                updated_history = list(set(prev_notified_hashes + current_rooms_hashes))  # [192]
                next_status_data[safe_key] = updated_history  # [193]
  # [194]
        browser.close()  # [195]
      # [196]
    with open(STATUS_FILE, "w", encoding="utf-8") as f:  # [197]
        json.dump(next_status_data, f, ensure_ascii=False, indent=2)  # [198]
  # [199]
if __name__ == "__main__":  # [200]
    main()  # [201]
